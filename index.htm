<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="Style.css">
  <link rel="stylesheet" href="Progress.css">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
  <div class="container">
    <h1>Browser built in LLM</h1>
    <h2>Talk to the browser's prompt API, see what it knows.</h2>
    <div class="header">
      <a link href="index.htm">Chat</a> | 
      <a link href="Benchmark.htm">Benchmark</a> | 
      <a link href="quality.htm">Quality</a>
    </div>

    <div class="settings-panel">
      <div id="settings-content" class="settings-content hidden">
        <div class="setting-item">
          <label for="temperature">Temperature:</label>
          <input type="range" id="temperature" min="0" max="1" step="0.1" value="1.0">
          <span id="temperature-value">1.0</span>
        </div>
        <div class="setting-item">
          <label for="topk">Top K:</label>
          <input type="number" id="topk" min="1" max="100" value="1">
        </div>
        <div class="setting-item">
          <label for="system-prompt">System Prompt:</label>
          <textarea id="system-prompt" rows="3" placeholder="Enter system prompt here..."></textarea>
        </div>
      </div>
    </div>

    <p id="error">
    </p>
    <div id="okay">
      <!--<p>SUCCESS: Prompt API supported. </p>-->
      <p>
        <b>
          Latency TTFT <b id="latency">0</b>ms</b> | <b id="tps">0</b><b> tokens/s </b>
      </p>
    </div>
    <div class="wrapper" id="busy">
      <div class="progressbar">
        <div class="stylization">
        </div>
      </div>
    </div>
    <div class="imessage">
    </div>
    <textarea id="input"
      name="input">Summarize:
      As of now, **NVIDIA Nsight Graphics** does not natively support **WebGPU**, because WebGPU is a relatively new API designed to 
      offer more modern graphics capabilities directly from web browsers, whereas Nsight focuses primarily on low-level graphics APIs like Vulkan, Direct3D, and OpenGL. However, there are still ways to profile **WebGPU shaders**, either by using WebGPU-specific tools or by leveraging alternative strategies in conjunction with Nsight.
      ### Here's how you can approach profiling WebGPU shaders:
      ### 1. **Browser's Developer Tools**
      WebGPU runs inside web browsers, so the primary way to profile WebGPU shaders is through the browser's built-in developer tools.
      - **Google Chrome** (and other Chromium-based browsers) have a WebGPU implementation. The **Performance tab** can give some general insight into GPU workload and execution times.
      - However, this is not as detailed as using tools like Nsight for native APIs like Vulkan.
      You can follow these steps for basic profiling:
         - Open **Chrome DevTools** (F12 or right-click and choose Inspect).
         - Go to the **Performance** tab.
         - Start recording while running your WebGPU workload.
         - Stop the recording to analyze the GPU time and function calls.
      For **WebGPU shader debugging**, WebGPU currently doesn't provide as many sophisticated tools for low-level shader profiling as Vulkan or DirectX.
      ### 2. **Emulate WebGPU with Vulkan and Use Nsight**
      To use **NVIDIA Nsight Graphics** or other advanced GPU profiling tools (which are generally more mature than WebGPU's current ecosystem), you can take an indirect approach:
      - **WGPU** is a popular Rust-based implementation of WebGPU, which can compile WebGPU code to Vulkan, Metal, or Direct3D 12.
         - By targeting **Vulkan** in a WebGPU project (using WGPU), you can capture the Vulkan API traces in Nsight Graphics.
         - This way, you can benefit from Nsight's advanced GPU profiling and shader analysis tools by profiling the Vulkan backend that your WebGPU project uses.
         Steps:
         1. Set up **WGPU** (or another WebGPU-to-Vulkan translation layer).
         2. Run your WebGPU code, but have it target the Vulkan backend.
         3. Open **NVIDIA Nsight Graphics** and capture a frame from the Vulkan-based WebGPU app.
         4. Analyze shader execution times, memory usage, and other GPU performance metrics using Nsight's tools.
      This approach allows you to leverage Vulkan profiling tools on WebGPU projects indirectly.
      ### 3. **Shader Profiling with Spirv-Cross**
      WebGPU shaders are written in **WGSL** or can be translated from HLSL/GLSL into SPIR-V using tools like **SPIRV-Cross**. If you're using SPIR-V shaders, Nsight Graphics can profile them once you've translated the WebGPU pipeline to Vulkan or other supported APIs.
      - **SPIR-V** shader code can be compiled using tools like **glslang** or **SPIRV-Tools** to ensure it's compatible with Vulkan.
      - Profiling SPIR-V shaders is supported by Nsight, so once you have your WebGPU shaders translated to SPIR-V, you can take advantage of Nsight's shader analysis capabilities.
      ### 4. **Monitor GPU Performance via Chrome's Internals**
      Although Nsight Graphics doesn't support WebGPU directly, you can monitor GPU usage through **Chromeâ€™s Task Manager** (Shift + Esc) to get rough insights into GPU memory usage and execution.
      Additionally, Chrome flags like `--enable-gpu-benchmarking` and `--enable-webgpu` might give you more low-level insight into how WebGPU commands are being dispatched.
      ### 5. **Wait for WebGPU Toolchain Maturity**
      As WebGPU matures, tools specifically designed to profile and debug WebGPU shaders will become more common. For example, upcoming features in **Google Chrome DevTools** and other WebGPU-focused browser tools could make shader profiling easier and more accessible without relying on Vulkan backends.
      ### Conclusion
      1. **Direct Nsight support for WebGPU** is currently not available.
      2. You can **use browser developer tools** (like Chrome's Performance tab) for high-level profiling.
      3. **Convert WebGPU to Vulkan** via **WGPU** or similar projects to profile using Nsight.
      4. Use **SPIR-V shaders** for more direct shader profiling via Nsight in Vulkan-based projects.
      While the tools for WebGPU shader profiling are not as mature as those for Vulkan or DirectX, the combination of browser tools and Vulkan translation layers can provide insights for performance tuning.</textarea>
    <button id="send" class="send-state"></button>
  </div>
</body>
<script type="module">
  let success = true;
  const kFeatureFlagError = "Prompt API is not detected. Check feature flags are enabled, and that this is Canary.</li>";
  const kNoModelError = "Prompt API is available, feature flag is likely set correctly but no models are available.";
  let session_controller = null;
  var session = null;
  let isStreaming = false;
  
  // Add model settings
  let modelSettings = {
    temperature: 1.0,
    topK: 1,
    systemPrompt: "You are a helpful agent, who provides accurate and concise information."
  };

  async function createSession()
  {
    showBusy(true);
    session_controller = new AbortController();
    session = await window.ai.languageModel.create({ 
      temperature: modelSettings.temperature, 
      topK: modelSettings.topK,
      systemPrompt: modelSettings.systemPrompt,
      signal: session_controller.signal 
    });
    showBusy(false);
  }

  // Settings panel functionality
  async function initializeSettings() {
    const settingsToggle = document.getElementById("settings-toggle");
    const settingsContent = document.getElementById("settings-content");
    const temperatureInput = document.getElementById("temperature");
    const temperatureValue = document.getElementById("temperature-value");
    const topkInput = document.getElementById("topk");
    const systemPromptInput = document.getElementById("system-prompt");

    settingsToggle.addEventListener("click", () => {
      settingsContent.classList.toggle("hidden");
    });

    temperatureInput.addEventListener("input", (e) => {
      modelSettings.temperature = parseFloat(e.target.value);
      temperatureValue.textContent = e.target.value;
      createSession();
    });

    topkInput.addEventListener("input", (e) => {
      modelSettings.topK = parseInt(e.target.value);
      createSession();
    });

    systemPromptInput.addEventListener("input", (e) => {
      modelSettings.systemPrompt = e.target.value;
      createSession();
    });
  }

  initializeSettings();

  function error(str) {
    // Show the first error.
    if (success) {
      document.getElementById("error").innerHTML = str;
      success = false;
    }
    showBusy(false);
    throw new Error(str);
  }
  function showBusy(busy) {
    document.getElementById("busy").style.display = busy ? "block" : "none";
  }
  async function checkDownload() {
    let result = null;
    if (window.ai.languageModel.capabilities) {
        result = await window.ai.languageModel.capabilities();
        if (result.available != 'readily') {
          window.setTimeout(checkDownload, 100);
        }
        if (result.available == 'readily') {
          window.location.reload();
        }
    } else {
        result = await window.ai.languageModel.availability();
        if (result != 'available') {
          window.setTimeout(checkDownload, 100);
        }
        if (result == 'available') {
          window.location.reload();
        }
    }
  }

  // Check for APi presence.
  try {
    let result = null;
    if (window.ai.languageModel.capabilities) {
        result = await window.ai.languageModel.capabilities();
        if (result.available == 'no') {
          error(kNoModelError);
        }
        if (result.available == 'after-download') {
          // call the API to trigger download.
          showBusy(true);
            window.ai.languageModel.create({
              monitor(m) {
              m.addEventListener("downloadprogress", e => {
                document.getElementById("error").innerHTML = `Downloading model ${Math.round(e.loaded/1000000)} of ${Math.round(e.total/1000000)} MB.`;
              });
              }
            });
            checkDownload();
        }
        if (result.available != 'readily') {
          error("Cannot create model now - " + result.available);
        }
    } else {
        result = await window.ai.languageModel.availability();
        if (result == 'unavailable') {
          error(kNoModelError);
        }
        if (result == 'downloadable' || result == 'downloading') {
          // call the API to trigger download.
          showBusy(true);
            window.ai.languageModel.create({
            monitor(m) {
            m.addEventListener("downloadprogress", e => {
              document.getElementById("error").innerHTML = `Downloading model ${Math.round(e.loaded/1000000)} of ${Math.round(e.total/1000000)} MB.`;
            });
            }
          });
          checkDownload();
        }
        if (result != 'available') {
          error("Cannot create model now - " + result.available);
        }
    }
  }
  catch (e) {
    if (e.name === "TypeError") {
      error(kFeatureFlagError);
    }
  }

  // Create the actual session.
  try {
    createSession();
  }
  catch (e) {
    error("Cannot create session now - " + e);
  }

  var update_element = null;
  var current_cps = 0;
  var initial_delay = null;
  var start_time = null;

  var post_prefill_time = null;
  var post_prefill_c = null;
  var post_prefill_t = null;

  var cps_element = document.getElementById("cps");
  var tps_element = document.getElementById("tps");
  var latency_element = document.getElementById("latency");
  var token_count = 0;
  var current_tps = 0;
  async function main(input) {
    update_element.scrollIntoView(false);
    let stream = null;
    try {
      showBusy(true);
      session_controller = new AbortController();
      stream = session.promptStreaming(input, { signal: session_controller.signal });
    }
    catch (e) {
      error("Cannot create stream now - " + e);
    }
    try {
      var response = "";
      for await (const chunk of stream) {
        showBusy(false);
        response += chunk;
        update_element.innerHTML = marked.parse(response);
        token_count++;
        // Wait for prefill to complete before we estimate tokens per second.
        if (token_count >= 2) {
          if (post_prefill_time) {
            const seconds = Math.floor((Date.now() - post_prefill_time) / 1000);
            current_cps = Math.round((update_element.innerText.length - post_prefill_c) / seconds);
            current_tps = Math.round((token_count - post_prefill_t) / seconds);
          }
          else {
            post_prefill_time = Date.now();
            post_prefill_c = update_element.innerText.length;
            post_prefill_t = token_count;
          }
        }
        if (initial_delay == null) {
          initial_delay = (Date.now() - start_time);
          latency_element.innerText = initial_delay;
        }
        // cps_element.innerText = current_cps;
        tps_element.innerText = current_tps;
        let imessage = document.getElementsByClassName("imessage")[0];
        imessage.scrollTop = imessage.scrollHeight;
      }
    }
    catch (e) {
      error("Stream error - " + e);
    }
  }

  async function onSend() {
    const sendButton = document.getElementById("send");
    
    if (isStreaming) {
      // Abort current stream
      session_controller.abort();
      session_controller = null;
      isStreaming = false;
      sendButton.classList.remove("abort-state");
      sendButton.classList.add("send-state");
      return;
    }
  
    const inputText = document.getElementById("input").value;
    if (!inputText.trim()) return; // Don't send empty messages
  
    // Create UI elements
    let input = document.createElement("p");
    input.setAttribute("class", "from-me");
    input.innerText = inputText;
    document.getElementsByClassName("imessage")[0].appendChild(input);
    let reply = document.createElement("p");
    reply.setAttribute("class", "from-them");
    document.getElementsByClassName("imessage")[0].appendChild(reply);
    update_element = reply;
    reply.innerText = "...";
  
    // Reset metrics
    start_time = Date.now();
    token_count = 0;
    post_prefill_time = null;
    post_prefill_c = null;
    post_prefill_t = null;
  
    // Create new session if needed
    if (!session) {
      await createSession();
    }
  
    isStreaming = true;
    sendButton.classList.remove("send-state");
    sendButton.classList.add("abort-state");
    await main(inputText);
    isStreaming = false;
    sendButton.classList.remove("abort-state");
    sendButton.classList.add("send-state");
  }
  document.getElementById("send").onclick = onSend;
  document.getElementById("okay").style.display = "block";
  document.getElementById("input").addEventListener("keypress", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      onSend();
    }
  });
  showBusy(false);
</script>

</html>
