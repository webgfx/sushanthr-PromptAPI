<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="Style.css">
  <link rel="stylesheet" href="Progress.css">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
  <div class="container">
    <h1>Browser built in LLM</h1>
    <h2>Talk to the browser's prompt API, see what it knows.</h2>
    <div class="header">
      <a link href="index.htm">Chat</a> | 
      <a link href="Benchmark.htm">Benchmark</a> | 
      <a link href="quality.htm">Quality</a>
    </div>

    <div class="settings-panel">
      <div id="settings-content" class="settings-content hidden">
        <div class="setting-item">
          <label for="temperature">Temperature:</label>
          <input type="range" id="temperature" min="0" max="1" step="0.1" value="1.0">
          <span id="temperature-value">1.0</span>
        </div>
        <div class="setting-item">
          <label for="topk">Top K:</label>
          <input type="number" id="topk" min="1" max="100" value="1">
        </div>
        <div class="setting-item">
          <label for="system-prompt">System Prompt:</label>
          <textarea id="system-prompt" rows="3" placeholder="Enter system prompt here..."></textarea>
        </div>
      </div>
    </div>

    <p id="error">
    </p>
    <p id="okay">
      SUCCESS: Prompt API supported. <span><a id="settings-toggle" class="settings-toggle">⚙️</a><b>Char/s <b id="cps">0</b></b>|<b>Tokens/s <b id="tps">0</b></b>|<b>Start
          Latency (ms)<b id="latency">0</b></b></span>
    </p>
    <div class="wrapper" id="busy">
      <div class="progressbar">
        <div class="stylization">
        </div>
      </div>
    </div>
    <div class="imessage">
    </div>
    <textarea id="input"
      name="input">What is Seattle famous for ?</textarea>
    <button id="send" class="send-state"></button>
  </div>
</body>
<script type="module">
  let success = true;
  const kFeatureFlagError = "Prompt API is not detected. Check feature flags are enabled, and that this is Canary.</li>";
  const kNoModelError = "Prompt API is available, feature flag is likely set correctly but no models are available.";
  let session_controller = null;
  var session = null;
  let isStreaming = false;
  
  // Add model settings
  let modelSettings = {
    temperature: 1.0,
    topK: 1,
    systemPrompt: "You are a helpful agent, who provides accurate and concise information."
  };

  async function createSession()
  {
    showBusy(true);
    session_controller = new AbortController();
    session = await window.ai.languageModel.create({ 
      temperature: modelSettings.temperature, 
      topK: modelSettings.topK,
      systemPrompt: modelSettings.systemPrompt,
      signal: session_controller.signal 
    });
    showBusy(false);
  }

  // Settings panel functionality
  async function initializeSettings() {
    const settingsToggle = document.getElementById("settings-toggle");
    const settingsContent = document.getElementById("settings-content");
    const temperatureInput = document.getElementById("temperature");
    const temperatureValue = document.getElementById("temperature-value");
    const topkInput = document.getElementById("topk");
    const systemPromptInput = document.getElementById("system-prompt");

    settingsToggle.addEventListener("click", () => {
      settingsContent.classList.toggle("hidden");
    });

    temperatureInput.addEventListener("input", (e) => {
      modelSettings.temperature = parseFloat(e.target.value);
      temperatureValue.textContent = e.target.value;
      createSession();
    });

    topkInput.addEventListener("input", (e) => {
      modelSettings.topK = parseInt(e.target.value);
      createSession();
    });

    systemPromptInput.addEventListener("input", (e) => {
      modelSettings.systemPrompt = e.target.value;
      createSession();
    });
  }

  initializeSettings();

  function error(str) {
    // Show the first error.
    if (success) {
      document.getElementById("error").innerHTML = str;
      success = false;
    }
    showBusy(false);
    throw new Error(str);
  }
  function showBusy(busy) {
    document.getElementById("busy").style.display = busy ? "block" : "none";
  }
  async function checkDownload() {
    let result = null;
    if (window.ai.languageModel.capabilities) {
        result = await window.ai.languageModel.capabilities();
        if (result.available != 'readily') {
          window.setTimeout(checkDownload, 100);
        }
        if (result.available == 'readily') {
          window.location.reload();
        }
    } else {
        result = await window.ai.languageModel.availability();
        if (result != 'available') {
          window.setTimeout(checkDownload, 100);
        }
        if (result == 'available') {
          window.location.reload();
        }
    }
  }

  // Check for APi presence.
  try {
    let result = null;
    if (window.ai.languageModel.capabilities) {
        result = await window.ai.languageModel.capabilities();
        if (result.available == 'no') {
          error(kNoModelError);
        }
        if (result.available == 'after-download') {
          // call the API to trigger download.
          showBusy(true);
            window.ai.languageModel.create({
              monitor(m) {
              m.addEventListener("downloadprogress", e => {
                document.getElementById("error").innerHTML = `Downloading model ${Math.round(e.loaded/1000000)} of ${Math.round(e.total/1000000)} MB.`;
              });
              }
            });
            checkDownload();
        }
        if (result.available != 'readily') {
          error("Cannot create model now - " + result.available);
        }
    } else {
        result = await window.ai.languageModel.availability();
        if (result == 'unavailable') {
          error(kNoModelError);
        }
        if (result == 'downloadable' || result == 'downloading') {
          // call the API to trigger download.
          showBusy(true);
            window.ai.languageModel.create({
            monitor(m) {
            m.addEventListener("downloadprogress", e => {
              document.getElementById("error").innerHTML = `Downloading model ${Math.round(e.loaded/1000000)} of ${Math.round(e.total/1000000)} MB.`;
            });
            }
          });
          checkDownload();
        }
        if (result != 'available') {
          error("Cannot create model now - " + result.available);
        }
    }
  }
  catch (e) {
    if (e.name === "TypeError") {
      error(kFeatureFlagError);
    }
  }

  // Create the actual session.
  try {
    createSession();
  }
  catch (e) {
    error("Cannot create session now - " + e);
  }

  var update_element = null;
  var current_cps = 0;
  var initial_delay = null;
  var start_time = null;

  var post_prefill_time = null;
  var post_prefill_c = null;
  var post_prefill_t = null;

  var cps_element = document.getElementById("cps");
  var tps_element = document.getElementById("tps");
  var latency_element = document.getElementById("latency");
  var token_count = 0;
  var current_tps = 0;
  async function main(input) {
    update_element.scrollIntoView(false);
    let stream = null;
    try {
      showBusy(true);
      session_controller = new AbortController();
      stream = session.promptStreaming(input, { signal: session_controller.signal });
    }
    catch (e) {
      error("Cannot create stream now - " + e);
    }
    try {
      var response = "";
      for await (const chunk of stream) {
        showBusy(false);
        response += chunk;
        update_element.innerHTML = marked.parse(response);
        token_count++;
        // Wait for prefill to complete before we estimate tokens per second.
        if (token_count >= 2) {
          if (post_prefill_time) {
            const seconds = Math.floor((Date.now() - post_prefill_time) / 1000);
            current_cps = Math.round((update_element.innerText.length - post_prefill_c) / seconds);
            current_tps = Math.round((token_count - post_prefill_t) / seconds);
          }
          else {
            post_prefill_time = Date.now();
            post_prefill_c = update_element.innerText.length;
            post_prefill_t = token_count;
          }
        }
        if (initial_delay == null) {
          initial_delay = (Date.now() - start_time);
          latency_element.innerText = initial_delay;
        }
        cps_element.innerText = current_cps;
        tps_element.innerText = current_tps;
      }
    }
    catch (e) {
      error("Stream error - " + e);
    }
  }

  async function onSend() {
    const sendButton = document.getElementById("send");
    
    if (isStreaming) {
      // Abort current stream
      session_controller.abort();
      session_controller = null;
      isStreaming = false;
      sendButton.classList.remove("abort-state");
      sendButton.classList.add("send-state");
      return;
    }
  
    const inputText = document.getElementById("input").value;
    if (!inputText.trim()) return; // Don't send empty messages
  
    // Create UI elements
    let input = document.createElement("p");
    input.setAttribute("class", "from-me");
    input.innerText = inputText;
    document.getElementsByClassName("imessage")[0].appendChild(input);
    let reply = document.createElement("p");
    reply.setAttribute("class", "from-them");
    document.getElementsByClassName("imessage")[0].appendChild(reply);
    update_element = reply;
    reply.innerText = "...";
  
    // Reset metrics
    start_time = Date.now();
    token_count = 0;
    post_prefill_time = null;
    post_prefill_c = null;
    post_prefill_t = null;
  
    // Create new session if needed
    if (!session) {
      await createSession();
    }
  
    isStreaming = true;
    sendButton.classList.remove("send-state");
    sendButton.classList.add("abort-state");
    await main(inputText);
    isStreaming = false;
    sendButton.classList.remove("abort-state");
    sendButton.classList.add("send-state");
  }
  document.getElementById("send").onclick = onSend;
  document.getElementById("okay").style.display = "block";
  document.getElementById("input").addEventListener("keypress", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      onSend();
    }
  });
  showBusy(false);
</script>

</html>
